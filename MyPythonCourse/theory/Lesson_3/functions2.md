1. **Lambda-выражения**: Нужно объяснить, что это анонимные функции, которые можно использовать там, где требуется простая функция на короткое время. Примеры: сортировка списка с ключом, использование в функциях высшего порядка. Важно подчеркнуть ограничения — лямбды могут содержать только одно выражение.

2. **Функции высшего порядка (map, reduce, filter, all)**: 
   - **map**: Применяет функцию к каждому элементу итерируемого объекта. Пример: преобразование списка чисел в их квадраты.
   - **reduce**: Нужно импортировать из functools. Накопление результата путем последовательного применения функции. Пример: сумма элементов списка.
   - **filter**: Фильтрация элементов по условию. Пример: выбор чётных чисел.
   - **all**: Проверяет, все ли элементы итерируемого объекта истинны. Пример: проверка, все ли числа положительные.

3. **Преобразование типов**: Встроенные функции типа int(), str(), list() и т.д. Пример: преобразование строки в число, списка кортежей в словарь с помощью dict().

4. **Область видимости переменных**: 
   - Локальные переменные внутри функции.
   - Глобальные переменные, объявленные через global.
   - Нелокальные (nonlocal) для вложенных функций. Пример: изменение переменной внешней функции из вложенной.

5. **Замыкания**: Функции, запоминающие переменные из внешней области видимости. Пример: функция-счётчик, которая запоминает количество вызовов.

6. **Декораторы**: Функции, которые оборачивают другие функции для добавления функциональности. Пример: декоратор для замера времени выполнения функции. Нужно объяснить синтаксис с @, цепочки декораторов.

### **2 часть: Продвинутые функции в Python**

---

#### **1. Lambda-выражения**
- **Лямбда** — анонимная функция, записанная в одну строку.
- **Синтаксис**: `lambda параметры: выражение`.
- **Особенности**:
  - Нет имени (кроме присвоения переменной).
  - Может принимать любое число аргументов.
  - Тело — одно выражение (нельзя использовать `return`, циклы, условия в многострочном формате).

**Примеры**:
```python
# Простая лямбда
square = lambda x: x ** 2
print(square(5))  # 25

# Лямбда в сортировке
users = [{"name": "Alice", "age": 30}, {"name": "Bob", "age": 25}]
users_sorted = sorted(users, key=lambda u: u["age"])  # Сортировка по возрасту

# Лямбда с несколькими аргументами
add = lambda a, b: a + b
print(add(3, 7))  # 10
```

**Ограничения**:
- Не подходит для сложной логики (используйте обычные функции).

---

#### **2. Функции высшего порядка**
Функции, принимающие или возвращающие другие функции.

**a. `map(func, iterable)`**  
Применяет `func` к каждому элементу `iterable`.
```python
numbers = [1, 2, 3, 4]
squared = list(map(lambda x: x ** 2, numbers))  # [1, 4, 9, 16]
```

**b. `filter(func, iterable)`**  
Возвращает элементы, для которых `func` возвращает `True`.
```python
evens = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]
```

**c. `reduce(func, iterable)`**  
Накопление результата (требуется `from functools import reduce`).
```python
from functools import reduce
sum_all = reduce(lambda a, b: a + b, numbers)  # 10
```

**d. `all(iterable)`**  
Проверяет, все ли элементы `True`.
```python
data = [5, 3, 8]
print(all(x > 0 for x in data))  # True (все положительные)
```

---

#### **3. Преобразование типов**
Встроенные функции для явного изменения типов данных:
- `int()`, `float()`, `str()`
- `list()`, `tuple()`, `set()`, `dict()`
- `bool()`

**Примеры**:
```python
num_str = "123"
num = int(num_str)  # 123 (целое число)

chars = ['a', 'b', 'c']
str_from_list = ''.join(chars)  # "abc" (преобразование списка в строку)

pairs = [("name", "Alice"), ("age", 30)]
user_dict = dict(pairs)  # {'name': 'Alice', 'age': 30}
```

---

#### **4. Область видимости переменных**
- **Локальные переменные**: Определены внутри функции.
- **Глобальные переменные**: Объявлены в основном коде (доступны через `global`).
- **Нелокальные (nonlocal)**: Из внешней функции (для вложенных функций).

**Пример**:
```python
x = 10  # Глобальная

def outer():
    y = 20  # Нелокальная для inner()
    def inner():
        nonlocal y
        y = 30  # Изменяет y в outer()
        global x
        x = 40  # Изменяет глобальную x
    inner()
    print(y)  # 30

outer()
print(x)  # 40
```

---

#### **5. Замыкания**
Функция, запоминающая переменные из внешней области видимости.

**Пример**: Счётчик вызовов
```python
def counter():
    count = 0
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

c = counter()
print(c(), c(), c())  # 1 2 3
```

**Применение**:
- Сохранение состояния между вызовами.
- Создание функций с предустановленными параметрами.

---

#### **6. Декораторы**
Функции, оборачивающие другие функции для расширения их функциональности.

**Синтаксис**:
```python
@decorator
def func():
    ...
```

**Пример**: Декоратор для замера времени выполнения
```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"Время выполнения: {end - start:.2f} сек.")
        return result
    return wrapper

@timer
def long_running_func():
    time.sleep(2)

long_running_func()  # Время выполнения: 2.00 сек.
```

**Цепочка декораторов**:
```python
@decorator1
@decorator2
def func():
    ...
# Эквивалентно: func = decorator1(decorator2(func))
```

**Декораторы с параметрами**:
```python
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def say_hello():
    print("Hello")

say_hello()  # Выведет "Hello" 3 раза
```

---

**Итог**:  
Продвинутые техники работы с функциями позволяют писать более гибкий и выразительный код. Лямбды упрощают однострочные операции, функции высшего порядка (`map`, `filter`, `reduce`) — обработку коллекций, а декораторы и замыкания помогают в создании модульных и переиспользуемых компонентов. Понимание областей видимости и преобразования типов критично для избежания ошибок.